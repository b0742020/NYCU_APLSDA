//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module VGA_P4(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SEG7 //////////
	/*output	reg	     [6:0]		HEX0,
	output	reg	     [6:0]		HEX1,
	output	reg	     [6:0]		HEX2,
	output	reg	     [6:0]		HEX3,
	output	reg	     [6:0]		HEX4,
	output	reg	     [6:0]		HEX5,
	*/
	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// VGA //////////
	output		          			VGA_BLANK_N,
	output		reg     [7:0]		VGA_B,
	output		          			VGA_CLK,
	output		reg     [7:0]		VGA_G,
	output		    	      		VGA_HS,
	output		reg     [7:0]		VGA_R,
	output		        	  			VGA_SYNC_N,
	output		          			VGA_VS
	
	//////////// SDRAM //////////
	/*output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,
	*/
	//////////// HPS //////////
	/*inout 		          		HPS_CONV_USB_N,
	output		    [14:0]		HPS_DDR3_ADDR,
	output		     [2:0]		HPS_DDR3_BA,
	output		          		HPS_DDR3_CAS_N,
	output		          		HPS_DDR3_CKE,
	output		          		HPS_DDR3_CK_N,
	output		          		HPS_DDR3_CK_P,
	output		          		HPS_DDR3_CS_N,
	output		     [3:0]		HPS_DDR3_DM,
	inout 		    [31:0]		HPS_DDR3_DQ,
	inout 		     [3:0]		HPS_DDR3_DQS_N,
	inout 		     [3:0]		HPS_DDR3_DQS_P,
	output		          		HPS_DDR3_ODT,
	output		          		HPS_DDR3_RAS_N,
	output		          		HPS_DDR3_RESET_N,
	input 		          		HPS_DDR3_RZQ,
	output		          		HPS_DDR3_WE_N,
	output		          		HPS_ENET_GTX_CLK,
	inout 		          		HPS_ENET_INT_N,
	output		          		HPS_ENET_MDC,
	inout 		          		HPS_ENET_MDIO,
	input 		          		HPS_ENET_RX_CLK,
	input 		     [3:0]		HPS_ENET_RX_DATA,
	input 		          		HPS_ENET_RX_DV,
	output		     [3:0]		HPS_ENET_TX_DATA,
	output		          		HPS_ENET_TX_EN,
	inout 		     [3:0]		HPS_FLASH_DATA,
	output		          		HPS_FLASH_DCLK,
	output		          		HPS_FLASH_NCSO,
	inout 		     [1:0]		HPS_GPIO,
	inout 		          		HPS_GSENSOR_INT,
	inout 		          		HPS_I2C1_SCLK,
	inout 		          		HPS_I2C1_SDAT,
	inout 		          		HPS_I2C2_SCLK,
	inout 		          		HPS_I2C2_SDAT,
	inout 		          		HPS_I2C_CONTROL,
	inout 		          		HPS_KEY,
	inout 		          		HPS_LED,
	output		          		HPS_SD_CLK,
	inout 		          		HPS_SD_CMD,
	inout 		     [3:0]		HPS_SD_DATA,
	output		          		HPS_SPIM_CLK,
	input 		          		HPS_SPIM_MISO,
	output		          		HPS_SPIM_MOSI,
	inout 		          		HPS_SPIM_SS,
	input 		          		HPS_UART_RX,
	output		          		HPS_UART_TX,
	input 		          		HPS_USB_CLKOUT,
	inout 		     [7:0]		HPS_USB_DATA,
	input 		          		HPS_USB_DIR,
	input 		          		HPS_USB_NXT,
	output		          		HPS_USB_STP
*/
);

//=======================================================
//  PARAMETER declarations
//=======================================================

//	Horizontal Parameter	( Pixel )
parameter	H_SYNC_CYC	=	96;
parameter	H_SYNC_BACK	=	48;
parameter	H_SYNC_ACT	=	640;
parameter	H_SYNC_FRONT=	16;
parameter	H_SYNC_TOTAL=	800;

//	Virtical Parameter		( Line )
parameter	V_SYNC_CYC	=	2;
parameter	V_SYNC_BACK	=	33;
parameter	V_SYNC_ACT	=	480;
parameter	V_SYNC_FRONT=	10;
parameter	V_SYNC_TOTAL=	525;
//	Start Offset
parameter	X_START		=	H_SYNC_CYC+H_SYNC_BACK;
parameter	Y_START		=	V_SYNC_CYC+V_SYNC_BACK;




//=======================================================
//  REG/WIRE declarations
//=======================================================
wire CLOCK_25;
wire iStart_n = SW[9];

reg reset = 1'b0;

//	Internal Registers and Wires
reg		[11:0]		H_Cont = 12'b0;
reg		[11:0]		V_Cont = 12'b0;
reg     [11:0]		en_cnt = 12'b0;

reg [255:0]cnt_hs;
reg [255:0]cnt_vs;
reg [23:0]oRGB;
reg vga_hs;
reg vga_vs;


reg[7:0]R;
reg[7:0]G;
reg[7:0]B;

reg [23:0]fifo[0:307199];
reg [23:0]pixel;

// reg[23:0]en_cnt;

reg enable;

wire book;
wire data_en;
wire H_wire;
wire V_wire;

//=======================================================
//  Structural coding
//=======================================================
assign VGA_BLANK_N = data_en;
assign VGA_SYNC_N = 1'b0;
assign VGA_CLK = CLOCK_25;


input_badge u_input_badge(
	.iStart_n(SW[7]),
	.iCLK(CLOCK_25),
	.iRST_N(SW[8]),

	.oData_Enable(data_en),
	.oData(oRGB),
	.HSYNC(H_wire),
	.VSYNC(V_wire)
);

PLL u1(
		.refclk(CLOCK_50),   //  refclk.clk
		.rst(reset),      //   reset.reset
		.outclk_0(CLOCK_25), // outclk0.clk
		.locked()    //  locked.export
	);


assign VGA_HS = H_wire;
assign VGA_VS = V_wire;
	

always@(posedge CLOCK_25 or negedge KEY[0])begin
	if(!KEY[0])begin
		pixel <= 0;
	end
	else begin
		if(pixel < 307199)begin
			pixel <= pixel + 1'b1;
		end
		else begin
			pixel <= pixel;
		end
	end
end	


always@(posedge CLOCK_25 or negedge KEY[0])begin
	if(!KEY[0])begin
		fifo[pixel] <= 24'b0;
	end
	else begin
		if(pixel == 0)begin
			fifo[pixel] <= oRGB;
		end
		else if(pixel<307199)begin
			fifo[pixel+1] <=fifo[pixel];
		end
		else begin
			fifo[pixel] <= fifo[pixel];
		end
	end
end


always@(posedge CLOCK_25 or negedge KEY[3])begin
	if(!KEY[3])begin
		cnt_hs <= 0;
	end
	else begin
		if(data_en && cnt_hs < 640)begin
			cnt_hs <= cnt_hs + 1;
		end
		else if(cnt_hs == 640)begin
			cnt_hs <= 0;
		end
		else begin
			cnt_hs <= cnt_hs;
		end
	end
end


always@(posedge CLOCK_25 or negedge KEY[3])begin
	if(!KEY[3])begin
		cnt_vs <= 0;
	end
	else begin
		if( cnt_hs ==640 && cnt_vs < 480)begin
				cnt_vs <= cnt_vs + 1;
		end
		else if(cnt_vs ==480)begin
				cnt_vs <= 0;
		end
		else begin
			cnt_vs <= cnt_vs;
		end
	end	
end


assign book = (cnt_vs>=197)&&(cnt_vs<207)&&(cnt_hs>=203)&&(cnt_hs<249);
//(cnt_hs>=203)&&(cnt_hs<249)
//(cnt_vs>=197)&&(cnt_vs<207)

always @ (posedge CLOCK_25 or negedge KEY[1])
		if (!KEY[1])
			{VGA_B,VGA_G,VGA_R} <= 24'd0;
		else
			if(book&&SW[0])begin
					{VGA_B,VGA_G,VGA_R} <= 24'hffffff;
			end
			else if(data_en==1'b1)
					{VGA_B,VGA_G,VGA_R} <= oRGB;
								
			else
				{VGA_B,VGA_G,VGA_R} <= 24'h0;



endmodule
